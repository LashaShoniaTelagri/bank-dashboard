name: ğŸ—„ï¸ Database Migrations

# This workflow runs database migrations independently of the main deployment
# Use this for:
# - Emergency database fixes
# - Testing migrations in specific environments
# - Manual migration runs outside normal deployment cycle

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to run migrations against'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      migration_action:
        description: 'Migration action to perform'
        required: true
        default: 'push'
        type: choice
        options:
          - push    # Apply new migrations
          - reset   # Reset database (DANGEROUS - removes all data)
          - repair  # Repair migration state
          - list    # List migration status only
      confirm_destructive:
        description: 'Type "CONFIRM" to allow destructive operations (reset)'
        required: false
        type: string

env:
  NODE_VERSION: '20'

jobs:
  # Determine environment settings
  environment:
    name: ğŸ¯ Determine Environment
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.env.outputs.env }}
      project_id: ${{ steps.env.outputs.project_id }}
    
    steps:
      - name: ğŸ¯ Set environment configuration
        id: env
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "env=${ENV}" >> $GITHUB_OUTPUT
          
          # Set project ID based on environment
          case ${ENV} in
            prod)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_PROD || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_STAGING || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_DEV || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo "ğŸ¯ Target environment: ${ENV}"

  # Validation for destructive operations
  validate:
    name: ğŸ” Validate Operation
    runs-on: ubuntu-latest
    needs: [environment]
    if: github.event.inputs.migration_action == 'reset'
    
    steps:
      - name: ğŸš¨ Validate destructive operation
        run: |
          if [ "${{ github.event.inputs.confirm_destructive }}" != "CONFIRM" ]; then
            echo "âŒ Destructive operation requires confirmation"
            echo "Please type 'CONFIRM' in the confirm_destructive field"
            exit 1
          fi
          
          if [ "${{ needs.environment.outputs.env }}" == "prod" ]; then
            echo "ğŸš¨ WARNING: You are about to reset the PRODUCTION database!"
            echo "This will DELETE ALL DATA in the production environment"
            echo "Proceeding in 10 seconds... Cancel now if this is not intended"
            sleep 10
          fi
          
          echo "âœ… Destructive operation confirmed"

  # Run database migrations
  migrate:
    name: ğŸ—„ï¸ Run Migrations
    runs-on: ubuntu-latest
    needs: [environment]
    # Skip validation job dependency for non-destructive operations
    # For destructive operations, validation must pass
    if: |
      github.event.inputs.migration_action != 'reset' || 
      (github.event.inputs.migration_action == 'reset' && needs.validate.result == 'success')
    environment: ${{ needs.environment.outputs.env }}
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ“¥ Install dependencies
        run: npm ci

      - name: ğŸ”§ Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: ğŸ”§ Setup database connection
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ needs.environment.outputs.project_id }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
        run: |
          echo "ğŸ”§ Setting up database connection (${{ needs.environment.outputs.env }})..."
          echo "Project ID: $SUPABASE_PROJECT_ID"
          echo "Access Token: ${SUPABASE_ACCESS_TOKEN:+Set}${SUPABASE_ACCESS_TOKEN:-Not Set}"
          echo "DB Password: ${SUPABASE_DB_PASSWORD:+Set}${SUPABASE_DB_PASSWORD:-Not Set}"
          
          if [ -z "$SUPABASE_DB_PASSWORD" ]; then
            echo "âŒ SUPABASE_DB_PASSWORD is not set!"
            echo "Please add SUPABASE_DB_PASSWORD to GitHub repository secrets"
            exit 1
          fi
          
          # Construct and save database URL for subsequent steps
          # Using pooled connection for CI/CD compatibility (direct connection has IPv6 issues in GitHub Actions)
          # Added pgbouncer=true and connection_limit=1 to minimize prepared statement conflicts
          DB_URL="postgresql://postgres.${SUPABASE_PROJECT_ID}:${SUPABASE_DB_PASSWORD}@aws-1-us-east-2.pooler.supabase.com:6543/postgres"
          echo "DB_URL=$DB_URL" >> $GITHUB_ENV
          echo "âœ… Database connection configured (using pooled connection with conflict mitigation)"

      - name: ğŸ“‹ List current migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ“‹ Current migration status:"
          
          # Enhanced retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              
              # Capture both stdout and stderr
              local output
              if output=$(eval "$cmd" 2>&1); then
                echo "âœ… Command succeeded on attempt $attempt"
                echo "$output"
                return 0
              else
                echo "âŒ Command failed on attempt $attempt"
                echo "$output"
                
                # Check for specific "up to date" messages
                if echo "$output" | grep -q "Remote database is up to date"; then
                  echo "âœ… Database is already up to date - treating as success"
                  return 0
                fi
                
                # Check for prepared statement errors that might indicate up-to-date database
                if echo "$output" | grep -q "prepared statement.*already exists"; then
                  echo "âš ï¸ Prepared statement conflict detected"
                  # For db push commands, this typically means database is already up to date
                  if echo "$cmd" | grep -q "db push"; then
                    echo "âœ… Database is already up to date - treating prepared statement conflict as success"
                    return 0
                  # For migration list commands, also treat as success since connection is working
                  elif echo "$cmd" | grep -q "migration list"; then
                    echo "âœ… Migration list connection works despite prepared statement conflict - treating as success"
                    return 0
                  else
                    echo "âš ï¸ Prepared statement conflict in other command - continuing retry..."
                  fi
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "ğŸš¨ All attempts failed"
                  return 1
                fi
                echo "â³ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase migration list --db-url '$DB_URL'"

      - name: ğŸ—„ï¸ Apply migrations (push)
        if: github.event.inputs.migration_action == 'push'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID }}
        run: |
          echo "ğŸ—„ï¸ Running database migrations using Supabase CLI..."
          
          # Export environment variables for Supabase CLI
          export SUPABASE_ACCESS_TOKEN
          export SUPABASE_DB_PASSWORD  
          export SUPABASE_PROJECT_ID
          
          echo "Project ID: ${SUPABASE_PROJECT_ID:0:3}***"
          echo "Access Token: ${SUPABASE_ACCESS_TOKEN:+Set}${SUPABASE_ACCESS_TOKEN:-Not Set}"
          echo "DB Password: ${SUPABASE_DB_PASSWORD:+Set}${SUPABASE_DB_PASSWORD:-Not Set}"
          
          # Pre-validation: Check Supabase CLI and credentials
          echo "ğŸ” Pre-validation checks..."
          
          # Verify Supabase CLI is available
          if ! command -v supabase >/dev/null 2>&1; then
            echo "âŒ Supabase CLI not found"
            exit 1
          fi
          
          echo "âœ… Supabase CLI version: $(supabase --version)"
          
          # Verify required environment variables
          if [ -z "$SUPABASE_ACCESS_TOKEN" ] || [ -z "$SUPABASE_DB_PASSWORD" ] || [ -z "$SUPABASE_PROJECT_ID" ]; then
            echo "âŒ Missing required environment variables"
            exit 1
          fi
          
          echo "âœ… All required environment variables are set"
          
          # Link project using exported environment variables
          echo "ğŸ”— Linking to Supabase project..."
          if supabase link --project-ref "$SUPABASE_PROJECT_ID"; then
            echo "âœ… Project linked successfully"
          else
            echo "âŒ Failed to link project"
            exit 1
          fi
          
          # Pre-migration validation: Check current migration status
          echo "ğŸ“‹ Pre-migration validation..."
          echo "Current migration status:"
          supabase migration list || {
            echo "âš ï¸ Could not retrieve migration list, but continuing..."
          }
          
          # Apply migrations
          echo "ğŸš€ Applying database migrations..."
          if supabase db push; then
            echo "âœ… Migrations applied successfully"
          else
            echo "âŒ Migration failed"
            
            # Post-failure diagnostics
            echo "ğŸ” Post-failure diagnostics..."
            echo "Migration status after failure:"
            supabase migration list || echo "Could not retrieve migration status"
            
            echo "Database diff (if any):"
            supabase db diff || echo "Could not retrieve database diff"
            
            exit 1
          fi
          
          # Post-migration validation
          echo "ğŸ“Š Post-migration validation..."
          
          # Verify migration status
          echo "Final migration status:"
          supabase migration list
          
          # Check for any schema differences
          echo "Checking for remaining schema differences..."
          if supabase db diff; then
            echo "âš ï¸ Schema differences detected after migration"
          else
            echo "âœ… No schema differences - migrations fully applied"
          fi
          
          # Basic table verification using SQL query
          echo "ğŸ” Verifying key database objects..."
          if supabase db reset --linked --debug 2>&1 | head -20 | grep -q "Connected to project" || \
             echo "SELECT 'Database connection verified'" | supabase db reset --linked --sql 2>/dev/null | grep -q "verified"; then
            echo "âœ… Database connectivity verified"
          else
            echo "âš ï¸ Could not verify database connectivity (this may be normal)"
          fi
          
          echo "âœ… Migration process completed successfully"

      - name: ğŸš¨ Reset database (DESTRUCTIVE)
        if: github.event.inputs.migration_action == 'reset'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸš¨ RESETTING DATABASE - THIS WILL DELETE ALL DATA!"
          
          # Retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "âœ… Command succeeded on attempt $attempt"
                return 0
              else
                echo "âŒ Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "ğŸš¨ All attempts failed"
                  return 1
                fi
                echo "â³ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase db reset --db-url '$DB_URL'"
          echo "âœ… Database reset completed"

      - name: ğŸ”§ Repair migration state
        if: github.event.inputs.migration_action == 'repair'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ”§ Repairing migration state..."
          
          # Retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "âœ… Command succeeded on attempt $attempt"
                return 0
              else
                echo "âŒ Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "ğŸš¨ All attempts failed"
                  return 1
                fi
                echo "â³ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase migration repair --db-url '$DB_URL' --status applied --version $(ls supabase/migrations/ | tail -1 | cut -d'_' -f1)"
          echo "âœ… Migration state repaired"

      - name: ğŸ“Š Final migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ“Š Final migration status:"
          
          # Retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "âœ… Command succeeded on attempt $attempt"
                return 0
              else
                echo "âŒ Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "ğŸš¨ All attempts failed"
                  return 1
                fi
                echo "â³ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase migration list --db-url '$DB_URL'"
          echo ""
          echo "ğŸ—„ï¸ Database schema info:"
          retry_command "supabase db diff --db-url '$DB_URL'" || echo "No schema differences detected"

  # Notification
  notify:
    name: ğŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [environment, migrate]
    if: always()
    
    steps:
      - name: ğŸ“¢ Migration notification
        run: |
          echo "ğŸ“Š Migration Summary:"
          echo "===================="
          echo "ğŸ¯ Environment: ${{ needs.environment.outputs.env }}"
          echo "ğŸ”§ Action: ${{ github.event.inputs.migration_action }}"
          echo "ğŸ“‹ Status: ${{ needs.migrate.result }}"
          echo ""
          
          if [ "${{ needs.migrate.result }}" == "success" ]; then
            echo "âœ… Database migration completed successfully!"
            case "${{ github.event.inputs.migration_action }}" in
              push)
                echo "ğŸ—„ï¸ New migrations have been applied"
                ;;
              reset)
                echo "ğŸš¨ Database has been reset (all data removed)"
                ;;
              repair)
                echo "ğŸ”§ Migration state has been repaired"
                ;;
              list)
                echo "ğŸ“‹ Migration status retrieved"
                ;;
            esac
          else
            echo "âŒ Migration operation failed!"
            echo "ğŸ“‹ Check the logs for details"
          fi 