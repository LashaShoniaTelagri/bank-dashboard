name: üóÑÔ∏è Database Migrations

# This workflow runs database migrations independently of the main deployment
# Use this for:
# - Emergency database fixes
# - Testing migrations in specific environments
# - Manual migration runs outside normal deployment cycle

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to run migrations against'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      migration_action:
        description: 'Migration action to perform'
        required: true
        default: 'push'
        type: choice
        options:
          - push    # Apply new migrations
          - reset   # Reset database (DANGEROUS - removes all data)
          - repair  # Repair migration state
          - list    # List migration status only
      confirm_destructive:
        description: 'Type "CONFIRM" to allow destructive operations (reset)'
        required: false
        type: string

env:
  NODE_VERSION: '18'

jobs:
  # Determine environment settings
  environment:
    name: üéØ Determine Environment
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.env.outputs.env }}
      project_id: ${{ steps.env.outputs.project_id }}
    
    steps:
      - name: üéØ Set environment configuration
        id: env
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "env=${ENV}" >> $GITHUB_OUTPUT
          
          # Set project ID based on environment
          case ${ENV} in
            prod)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_PROD || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_STAGING || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_DEV || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo "üéØ Target environment: ${ENV}"

  # Validation for destructive operations
  validate:
    name: üîç Validate Operation
    runs-on: ubuntu-latest
    needs: [environment]
    if: github.event.inputs.migration_action == 'reset'
    
    steps:
      - name: üö® Validate destructive operation
        run: |
          if [ "${{ github.event.inputs.confirm_destructive }}" != "CONFIRM" ]; then
            echo "‚ùå Destructive operation requires confirmation"
            echo "Please type 'CONFIRM' in the confirm_destructive field"
            exit 1
          fi
          
          if [ "${{ needs.environment.outputs.env }}" == "prod" ]; then
            echo "üö® WARNING: You are about to reset the PRODUCTION database!"
            echo "This will DELETE ALL DATA in the production environment"
            echo "Proceeding in 10 seconds... Cancel now if this is not intended"
            sleep 10
          fi
          
          echo "‚úÖ Destructive operation confirmed"

  # Run database migrations
  migrate:
    name: üóÑÔ∏è Run Migrations
    runs-on: ubuntu-latest
    needs: [environment]
    # Skip validation job dependency for non-destructive operations
    # For destructive operations, validation must pass
    if: |
      github.event.inputs.migration_action != 'reset' || 
      (github.event.inputs.migration_action == 'reset' && needs.validate.result == 'success')
    environment: ${{ needs.environment.outputs.env }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì• Install dependencies
        run: npm ci

      - name: üîß Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: üîß Setup database connection
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ needs.environment.outputs.project_id }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
        run: |
          echo "üîß Setting up database connection (${{ needs.environment.outputs.env }})..."
          echo "Project ID: $SUPABASE_PROJECT_ID"
          echo "Access Token: ${SUPABASE_ACCESS_TOKEN:+Set}${SUPABASE_ACCESS_TOKEN:-Not Set}"
          echo "DB Password: ${SUPABASE_DB_PASSWORD:+Set}${SUPABASE_DB_PASSWORD:-Not Set}"
          
          if [ -z "$SUPABASE_DB_PASSWORD" ]; then
            echo "‚ùå SUPABASE_DB_PASSWORD is not set!"
            echo "Please add SUPABASE_DB_PASSWORD to GitHub repository secrets"
            exit 1
          fi
          
          # Construct and save database URL for subsequent steps
          # Use direct connection (port 5432) instead of pooler (port 6543) to avoid prepared statement conflicts
          DB_URL="postgresql://postgres:${SUPABASE_DB_PASSWORD}@db.${SUPABASE_PROJECT_ID}.supabase.co:5432/postgres"
          echo "DB_URL=$DB_URL" >> $GITHUB_ENV
          echo "‚úÖ Database connection configured (using direct connection)"

      - name: üìã List current migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üìã Current migration status:"
          
          # Enhanced retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              
              # Capture both stdout and stderr
              local output
              if output=$(eval "$cmd" 2>&1); then
                echo "‚úÖ Command succeeded on attempt $attempt"
                echo "$output"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                echo "$output"
                
                # Check for specific "up to date" messages
                if echo "$output" | grep -q "Remote database is up to date"; then
                  echo "‚úÖ Database is already up to date - treating as success"
                  return 0
                fi
                
                # Check for prepared statement errors that might indicate up-to-date database
                if echo "$output" | grep -q "prepared statement.*already exists"; then
                  echo "‚ö†Ô∏è Prepared statement conflict detected"
                  # For db push commands, this typically means database is already up to date
                  if echo "$cmd" | grep -q "db push"; then
                    echo "‚úÖ Database is already up to date - treating prepared statement conflict as success"
                    return 0
                  # For migration list commands, also treat as success since connection is working
                  elif echo "$cmd" | grep -q "migration list"; then
                    echo "‚úÖ Migration list connection works despite prepared statement conflict - treating as success"
                    return 0
                  else
                    echo "‚ö†Ô∏è Prepared statement conflict in other command - continuing retry..."
                  fi
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "üö® All attempts failed"
                  return 1
                fi
                echo "‚è≥ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase migration list --db-url '$DB_URL'"

      - name: üóÑÔ∏è Apply migrations (push)
        if: github.event.inputs.migration_action == 'push'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üóÑÔ∏è Applying new migrations..."
          
          # Enhanced retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              
              # Capture both stdout and stderr
              local output
              if output=$(eval "$cmd" 2>&1); then
                echo "‚úÖ Command succeeded on attempt $attempt"
                echo "$output"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                echo "$output"
                
                # Check for specific "up to date" messages
                if echo "$output" | grep -q "Remote database is up to date"; then
                  echo "‚úÖ Database is already up to date - treating as success"
                  return 0
                fi
                
                # Check for prepared statement errors that might indicate up-to-date database
                if echo "$output" | grep -q "prepared statement.*already exists"; then
                  echo "‚ö†Ô∏è Prepared statement conflict detected"
                  # For db push commands, this typically means database is already up to date
                  if echo "$cmd" | grep -q "db push"; then
                    echo "‚úÖ Database is already up to date - treating prepared statement conflict as success"
                    return 0
                  # For migration list commands, also treat as success since connection is working
                  elif echo "$cmd" | grep -q "migration list"; then
                    echo "‚úÖ Migration list connection works despite prepared statement conflict - treating as success"
                    return 0
                  else
                    echo "‚ö†Ô∏è Prepared statement conflict in other command - continuing retry..."
                  fi
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "üö® All attempts failed"
                  return 1
                fi
                echo "‚è≥ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          # Verify connection before trying to push
          echo "Verifying Supabase connection..."
          retry_command "supabase migration list --db-url '$DB_URL'"
          
          echo "‚úÖ Connection verified. Applying migrations..."
          retry_command "supabase db push --db-url '$DB_URL'"
          echo "‚úÖ Migrations applied successfully"

      - name: üö® Reset database (DESTRUCTIVE)
        if: github.event.inputs.migration_action == 'reset'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üö® RESETTING DATABASE - THIS WILL DELETE ALL DATA!"
          
          # Retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "‚úÖ Command succeeded on attempt $attempt"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üö® All attempts failed"
                  return 1
                fi
                echo "‚è≥ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase db reset --db-url '$DB_URL'"
          echo "‚úÖ Database reset completed"

      - name: üîß Repair migration state
        if: github.event.inputs.migration_action == 'repair'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üîß Repairing migration state..."
          
          # Retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "‚úÖ Command succeeded on attempt $attempt"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üö® All attempts failed"
                  return 1
                fi
                echo "‚è≥ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase migration repair --db-url '$DB_URL' --status applied --version $(ls supabase/migrations/ | tail -1 | cut -d'_' -f1)"
          echo "‚úÖ Migration state repaired"

      - name: üìä Final migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "üìä Final migration status:"
          
          # Retry function for database operations
          retry_command() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt/$max_attempts: $cmd"
              if eval "$cmd"; then
                echo "‚úÖ Command succeeded on attempt $attempt"
                return 0
              else
                echo "‚ùå Command failed on attempt $attempt"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üö® All attempts failed"
                  return 1
                fi
                echo "‚è≥ Waiting 5 seconds before retry..."
                sleep 5
                attempt=$((attempt + 1))
              fi
            done
          }
          
          retry_command "supabase migration list --db-url '$DB_URL'"
          echo ""
          echo "üóÑÔ∏è Database schema info:"
          retry_command "supabase db diff --db-url '$DB_URL'" || echo "No schema differences detected"

  # Notification
  notify:
    name: üì¢ Notify
    runs-on: ubuntu-latest
    needs: [environment, migrate]
    if: always()
    
    steps:
      - name: üì¢ Migration notification
        run: |
          echo "üìä Migration Summary:"
          echo "===================="
          echo "üéØ Environment: ${{ needs.environment.outputs.env }}"
          echo "üîß Action: ${{ github.event.inputs.migration_action }}"
          echo "üìã Status: ${{ needs.migrate.result }}"
          echo ""
          
          if [ "${{ needs.migrate.result }}" == "success" ]; then
            echo "‚úÖ Database migration completed successfully!"
            case "${{ github.event.inputs.migration_action }}" in
              push)
                echo "üóÑÔ∏è New migrations have been applied"
                ;;
              reset)
                echo "üö® Database has been reset (all data removed)"
                ;;
              repair)
                echo "üîß Migration state has been repaired"
                ;;
              list)
                echo "üìã Migration status retrieved"
                ;;
            esac
          else
            echo "‚ùå Migration operation failed!"
            echo "üìã Check the logs for details"
          fi 