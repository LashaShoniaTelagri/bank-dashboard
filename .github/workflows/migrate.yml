name: ğŸ—„ï¸ Database Migrations

# This workflow runs database migrations independently of the main deployment
# Use this for:
# - Emergency database fixes
# - Testing migrations in specific environments
# - Manual migration runs outside normal deployment cycle

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to run migrations against'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      migration_action:
        description: 'Migration action to perform'
        required: true
        default: 'push'
        type: choice
        options:
          - push    # Apply new migrations
          - reset   # Reset database (DANGEROUS - removes all data)
          - repair  # Repair migration state
          - list    # List migration status only
      confirm_destructive:
        description: 'Type "CONFIRM" to allow destructive operations (reset)'
        required: false
        type: string

env:
  NODE_VERSION: '18'

jobs:
  # Determine environment settings
  environment:
    name: ğŸ¯ Determine Environment
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.env.outputs.env }}
      project_id: ${{ steps.env.outputs.project_id }}
    
    steps:
      - name: ğŸ¯ Set environment configuration
        id: env
        run: |
          ENV="${{ github.event.inputs.environment }}"
          echo "env=${ENV}" >> $GITHUB_OUTPUT
          
          # Set project ID based on environment
          case ${ENV} in
            prod)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_PROD || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_STAGING || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "project_id=${{ secrets.SUPABASE_PROJECT_ID_DEV || secrets.SUPABASE_PROJECT_ID }}" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo "ğŸ¯ Target environment: ${ENV}"

  # Validation for destructive operations
  validate:
    name: ğŸ” Validate Operation
    runs-on: ubuntu-latest
    needs: [environment]
    if: github.event.inputs.migration_action == 'reset'
    
    steps:
      - name: ğŸš¨ Validate destructive operation
        run: |
          if [ "${{ github.event.inputs.confirm_destructive }}" != "CONFIRM" ]; then
            echo "âŒ Destructive operation requires confirmation"
            echo "Please type 'CONFIRM' in the confirm_destructive field"
            exit 1
          fi
          
          if [ "${{ needs.environment.outputs.env }}" == "prod" ]; then
            echo "ğŸš¨ WARNING: You are about to reset the PRODUCTION database!"
            echo "This will DELETE ALL DATA in the production environment"
            echo "Proceeding in 10 seconds... Cancel now if this is not intended"
            sleep 10
          fi
          
          echo "âœ… Destructive operation confirmed"

  # Run database migrations
  migrate:
    name: ğŸ—„ï¸ Run Migrations
    runs-on: ubuntu-latest
    needs: [environment]
    # Skip validation job dependency for non-destructive operations
    # For destructive operations, validation must pass
    if: |
      github.event.inputs.migration_action != 'reset' || 
      (github.event.inputs.migration_action == 'reset' && needs.validate.result == 'success')
    environment: ${{ needs.environment.outputs.env }}
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ğŸ“¥ Install dependencies
        run: npm ci

      - name: ğŸ”§ Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: ğŸ” Link to Supabase project  
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_ID: ${{ needs.environment.outputs.project_id }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
        run: |
          echo "ğŸ” Linking to Supabase project (${{ needs.environment.outputs.env }})..."
          echo "Project ID: $SUPABASE_PROJECT_ID"
          echo "Access Token: ${SUPABASE_ACCESS_TOKEN:+Set}${SUPABASE_ACCESS_TOKEN:-Not Set}"
          echo "DB Password: ${SUPABASE_DB_PASSWORD:+Set}${SUPABASE_DB_PASSWORD:-Not Set}"
          
          if [ -z "$SUPABASE_DB_PASSWORD" ]; then
            echo "âŒ SUPABASE_DB_PASSWORD is not set!"
            echo "Please add SUPABASE_DB_PASSWORD to GitHub repository secrets"
            exit 1
          fi
          
          supabase link --project-ref $SUPABASE_PROJECT_ID --password "$SUPABASE_DB_PASSWORD"
          echo "âœ… Successfully linked to Supabase project"

      - name: ğŸ“‹ List current migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ“‹ Current migration status:"
          supabase migration list

      - name: ğŸ—„ï¸ Apply migrations (push)
        if: github.event.inputs.migration_action == 'push'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ—„ï¸ Applying new migrations..."
          
          # Verify we're linked before trying to push
          echo "Verifying Supabase connection..."
          if ! supabase migration list; then
            echo "âŒ Failed to connect to Supabase. Link may have failed."
            exit 1
          fi
          
          echo "âœ… Connection verified. Applying migrations..."
          supabase db push
          echo "âœ… Migrations applied successfully"

      - name: ğŸš¨ Reset database (DESTRUCTIVE)
        if: github.event.inputs.migration_action == 'reset'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸš¨ RESETTING DATABASE - THIS WILL DELETE ALL DATA!"
          supabase db reset --linked
          echo "âœ… Database reset completed"

      - name: ğŸ”§ Repair migration state
        if: github.event.inputs.migration_action == 'repair'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ”§ Repairing migration state..."
          supabase migration repair --status applied --version $(ls supabase/migrations/ | tail -1 | cut -d'_' -f1)
          echo "âœ… Migration state repaired"

      - name: ğŸ“Š Final migration status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ“Š Final migration status:"
          supabase migration list
          echo ""
          echo "ğŸ—„ï¸ Database schema info:"
          supabase db diff --linked || echo "No schema differences detected"

  # Notification
  notify:
    name: ğŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [environment, migrate]
    if: always()
    
    steps:
      - name: ğŸ“¢ Migration notification
        run: |
          echo "ğŸ“Š Migration Summary:"
          echo "===================="
          echo "ğŸ¯ Environment: ${{ needs.environment.outputs.env }}"
          echo "ğŸ”§ Action: ${{ github.event.inputs.migration_action }}"
          echo "ğŸ“‹ Status: ${{ needs.migrate.result }}"
          echo ""
          
          if [ "${{ needs.migrate.result }}" == "success" ]; then
            echo "âœ… Database migration completed successfully!"
            case "${{ github.event.inputs.migration_action }}" in
              push)
                echo "ğŸ—„ï¸ New migrations have been applied"
                ;;
              reset)
                echo "ğŸš¨ Database has been reset (all data removed)"
                ;;
              repair)
                echo "ğŸ”§ Migration state has been repaired"
                ;;
              list)
                echo "ğŸ“‹ Migration status retrieved"
                ;;
            esac
          else
            echo "âŒ Migration operation failed!"
            echo "ğŸ“‹ Check the logs for details"
          fi 