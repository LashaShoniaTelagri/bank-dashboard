name: ğŸŒ¾ Deploy TelAgri Bank Dashboard

# This workflow:
# - On PULL REQUEST: Only runs build, lint, test, and security scan (no deployment)
# - On PUSH (merge): Runs full pipeline including deployment to AWS  
# - On MANUAL: Allows manual deployment to any environment (dev, staging, prod)

on:
  push:
    branches:
      - main
      - dev
      - staging
  pull_request:
    branches:
      - main
      - dev
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  # Build and test the frontend
  build:
    name: ğŸ—ï¸ Build PWA
    runs-on: ubuntu-latest
    needs: [environment]
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: âš™ï¸ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/GithubActionsRole
          role-session-name: telagri-build-session
          aws-region: ${{ needs.environment.outputs.region }}

      - name: ğŸ“¥ Install dependencies
        run: npm ci

      - name: ğŸ” Lint code
        run: npm run lint

      - name: ğŸ”§ Fetch Environment Configuration from AWS
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
          AWS_REGION: ${{ needs.environment.outputs.region }}
        run: |
          echo "ğŸ”§ Fetching environment configuration from AWS Parameter Store"
          echo "Environment: $ENVIRONMENT"
          echo "Region: $AWS_REGION"
          echo "Parameter Path: /telagri/monitoring/$ENVIRONMENT/frontend/env"
          
          # Make the script executable
          chmod +x scripts/fetch-env-from-aws.sh
          
          # Fetch frontend environment configuration from AWS Parameter Store
          ./scripts/fetch-env-from-aws.sh "$ENVIRONMENT" "$AWS_REGION"
          
          # Validate that .env file was created and contains VITE_ variables
          if [ ! -f ".env" ]; then
            echo "âŒ .env file was not created"
            exit 1
          fi
          
          # Check if .env contains frontend variables
          VITE_COUNT=$(grep -c '^VITE_' .env || echo "0")
          if [ "$VITE_COUNT" -eq 0 ]; then
            echo "âš ï¸ Warning: No VITE_ variables found in .env file"
            echo "ğŸ“‹ .env file contents:"
            cat .env
          else
            echo "âœ… Found $VITE_COUNT frontend variables in .env file"
          fi

      - name: ğŸ—ï¸ Build PWA
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
        run: |
          echo "ğŸ—ï¸ Building PWA for environment: $ENVIRONMENT"
          npm run build

      - name: ğŸ“Š Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
          retention-days: 7

  # Determine deployment environment
  environment:
    name: ğŸ¯ Determine Environment
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.env.outputs.env }}
      domain: ${{ steps.env.outputs.domain }}
      region: ${{ steps.env.outputs.region }}
    
    steps:
      - name: ğŸ¯ Set environment
        id: env
        run: |
          if [ "${{ github.event.inputs.environment }}" != "" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="prod"
          elif [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            ENV="staging"
          elif [ "${{ github.ref }}" = "refs/heads/dev" ]; then
            ENV="dev"
          else
            ENV="dev"
          fi
          
          echo "env=${ENV}" >> $GITHUB_OUTPUT
          
          case ${ENV} in
            prod)
              echo "domain=dashboard.telagri.com" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "domain=dashboard-stg.telagri.com" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "domain=dashboard-dev.telagri.com" >> $GITHUB_OUTPUT
              ;;
          esac
          
          # Set AWS region (us-east-1 for all environments)
          echo "region=us-east-1" >> $GITHUB_OUTPUT
          
          echo "ğŸ¯ Deploying to: ${ENV}"
          echo "ğŸŒ Domain: $(cat $GITHUB_OUTPUT | grep domain | cut -d= -f2)"
          echo "ğŸŒ Region: us-east-1"

  # Run database migrations
  migrate:
    name: ğŸ—„ï¸ Run DB Migrations
    runs-on: ubuntu-latest
    needs: [build, environment]
    environment: ${{ needs.environment.outputs.env }}
    # Only run migrations on push events (when PRs are merged), not on pull_request events
    if: github.event_name != 'pull_request'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: ğŸ” Show migration status (pre)
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
        run: |
          supabase link --project-ref "$SUPABASE_PROJECT_REF" --debug
          supabase migration status --debug || true

      - name: ğŸ—„ï¸ Run database migrations
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
        run: |
          echo "ğŸ—„ï¸ Running database migrations using Supabase CLI..."
          if [ -z "$SUPABASE_ACCESS_TOKEN" ] || [ -z "$SUPABASE_PROJECT_REF" ]; then
            echo "âŒ Missing required Supabase secrets (SUPABASE_ACCESS_TOKEN or SUPABASE_PROJECT_REF)"
            exit 1
          fi
          supabase link --project-ref "$SUPABASE_PROJECT_REF" --debug
          supabase db push --linked --debug

      - name: âœ… Show migration status (post)
        run: |
          supabase migration status --debug || true

  # Deploy infrastructure with CDK
  deploy:
    name: ğŸš€ Deploy to AWS
    runs-on: ubuntu-latest
    needs: [build, environment, migrate]
    environment: ${{ needs.environment.outputs.env }}
    # Only deploy on push events (when PRs are merged), not on pull_request events
    if: github.event_name != 'pull_request'
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“Š Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist/

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            cdk/package-lock.json

      - name: ğŸ Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: âš™ï¸ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNT_ID }}:role/GithubActionsRole
          role-session-name: telagri-deploy-session
          aws-region: ${{ needs.environment.outputs.region }}

      - name: ğŸ“¦ Install CDK dependencies
        working-directory: cdk
        run: npm ci

      - name: ğŸ—ï¸ Build CDK
        working-directory: cdk
        run: npm run build

      - name: ğŸ” CDK Diff
        working-directory: cdk
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
          DOMAIN_NAME: ${{ needs.environment.outputs.domain }}
          CERTIFICATE_ARN: ${{ vars.CERTIFICATE_ARN }}
          AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ needs.environment.outputs.region }}
        run: |
          echo "ğŸ” Showing infrastructure changes..."
          # Ensure bootstrap before diff to avoid warnings
          npx cdk bootstrap aws://$AWS_ACCOUNT_ID/$AWS_REGION --force > /dev/null 2>&1 || true
          npm run diff || true

      - name: ğŸ”§ Ensure CDK Bootstrap
        working-directory: cdk
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
          DOMAIN_NAME: ${{ needs.environment.outputs.domain }}
          CERTIFICATE_ARN: ${{ vars.CERTIFICATE_ARN }}
          AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ needs.environment.outputs.region }}
        run: |
          echo "ğŸ”§ Ensuring CDK bootstrap is up to date..."
          # Update CDK bootstrap to latest version to fix role assumption warnings
          echo "ğŸ“¦ Updating CDK bootstrap for account $AWS_ACCOUNT_ID in region $AWS_REGION..."
          npx cdk bootstrap aws://$AWS_ACCOUNT_ID/$AWS_REGION --force
          echo "âœ… CDK bootstrap updated successfully"

      - name: ğŸš€ Deploy CDK Stack
        working-directory: cdk
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
          DOMAIN_NAME: ${{ needs.environment.outputs.domain }}
          CERTIFICATE_ARN: ${{ vars.CERTIFICATE_ARN }}
          AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ needs.environment.outputs.region }}
        run: |
          echo "ğŸš€ Deploying TelAgri Bank Dashboard to ${{ needs.environment.outputs.env }}..."
          npm run deploy

      - name: ğŸ“‹ Get Stack Outputs
        working-directory: cdk
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
        run: |
          echo "ğŸ“‹ Stack Outputs:"
          aws cloudformation describe-stacks \
            --stack-name "TelAgri-Bank-Dashboard-${{ needs.environment.outputs.env }}" \
            --query 'Stacks[0].Outputs' \
            --output table || true

      - name: ğŸ”§ Setup Supabase CLI for Edge Functions
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: ğŸ”§ Deploy Edge Functions
        env:
          ENVIRONMENT: ${{ needs.environment.outputs.env }}
          AWS_REGION: ${{ needs.environment.outputs.region }}
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          echo "ğŸ”§ Deploying Supabase Edge Functions..."
          
          # Export Supabase access token for CLI authentication
          export SUPABASE_ACCESS_TOKEN
          echo "Access Token: ${SUPABASE_ACCESS_TOKEN:+Set}${SUPABASE_ACCESS_TOKEN:-Not Set}"
          
          # Validate access token
          if [ -z "$SUPABASE_ACCESS_TOKEN" ]; then
            echo "âŒ SUPABASE_ACCESS_TOKEN is not set"
            exit 1
          fi
          
          # Fetch backend environment from Parameter Store
          echo "ğŸ”§ Fetching backend environment configuration..."
          aws ssm get-parameter \
            --name "/telagri/monitoring/${ENVIRONMENT}/backend/env" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text > env.backend.temp
          
          # Source environment variables
          set -a
          source env.backend.temp
          set +a
          
          # Link to Supabase project
          echo "ğŸ”— Linking to Supabase project: ${SUPABASE_PROJECT_ID}"
          supabase link --project-ref ${SUPABASE_PROJECT_ID} --password ${SUPABASE_DB_PASSWORD}
          
          # Deploy all Edge Functions dynamically
          echo "ğŸš€ Deploying Edge Functions..."
          
          # Find all Edge Functions in the supabase/functions directory
          if [ -d "supabase/functions" ]; then
            for function_dir in supabase/functions/*/; do
              if [ -d "$function_dir" ]; then
                function_name=$(basename "$function_dir")
                echo "ğŸ“¦ Deploying function: $function_name"
                
                if supabase functions deploy "$function_name" --no-verify-jwt; then
                  echo "âœ… Successfully deployed: $function_name"
                else
                  echo "âŒ Failed to deploy: $function_name"
                  exit 1
                fi
              fi
            done
          else
            echo "âš ï¸ No supabase/functions directory found"
          fi
          
          # Set Edge Function secrets dynamically
          echo "ğŸ” Setting Edge Function secrets..."
          
          # Define required secrets for Edge Functions
          declare -A secrets=(
            ["PROJECT_URL"]="${PROJECT_URL}"
            ["SERVICE_ROLE_KEY"]="${SERVICE_ROLE_KEY}"
            ["SENDGRID_API_KEY"]="${SENDGRID_API_KEY}"
            ["SENDGRID_FROM_EMAIL"]="${SENDGRID_FROM_EMAIL}"
          )
          
          # Set each secret with error handling
          for secret_name in "${!secrets[@]}"; do
            secret_value="${secrets[$secret_name]}"
            
            if [ -n "$secret_value" ] && [ "$secret_value" != "REPLACE_WITH_"* ]; then
              echo "ğŸ”‘ Setting secret: $secret_name"
              if supabase secrets set "$secret_name=$secret_value"; then
                echo "âœ… Successfully set secret: $secret_name"
              else
                echo "âŒ Failed to set secret: $secret_name"
                exit 1
              fi
            else
              echo "âš ï¸ Skipping secret $secret_name (not configured or placeholder value)"
            fi
          done
          
          # Cleanup
          rm -f env.backend.temp
          
          echo "âœ… Edge Functions deployed successfully!"

      - name: âœ… Deployment Success
        run: |
          echo "ğŸ‰ TelAgri Bank Dashboard successfully deployed!"
          echo "ğŸŒ URL: https://${{ needs.environment.outputs.domain }}"
          echo "ğŸ”§ Environment: ${{ needs.environment.outputs.env }}"
          echo "ğŸ“Š Build: ${{ github.sha }}"
          echo "âš¡ Edge Functions: Deployed"

  # Security scan (runs on all events)
  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    needs: [build]
    # Run security scan on all PRs and main branch pushes
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    permissions:
      security-events: write
      actions: read
      contents: read
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”’ Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          output: 'trivy-results.txt'

      - name: ğŸ“Š Display security scan results
        if: always()
        run: |
          echo "ğŸ”’ Security Scan Results:"
          echo "========================"
          if [ -f trivy-results.txt ]; then
            cat trivy-results.txt
          else
            echo "âœ… No vulnerabilities detected or scan output not generated"
          fi
          echo "========================"

  # Notification (only for deployments)
  notify:
    name: ğŸ“¢ Notify
    runs-on: ubuntu-latest
    needs: [migrate, deploy, environment]
    # Only notify on deployment attempts (not PRs), and always run regardless of deploy success/failure
    if: always() && github.event_name != 'pull_request'
    
    steps:
      - name: ğŸ“¢ Deployment notification
        run: |
          echo "ğŸ“Š Deployment Summary:"
          echo "====================="
          echo "ğŸ—„ï¸ Migrations: ${{ needs.migrate.result }}"
          echo "ğŸš€ Deployment: ${{ needs.deploy.result }}"
          echo "ğŸŒ Environment: ${{ needs.environment.outputs.env }}"
          echo ""
          
          if [ "${{ needs.migrate.result }}" == "success" ] && [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "âœ… TelAgri Bank Dashboard deployment fully successful!"
            echo "ğŸ”— URL: https://${{ needs.environment.outputs.domain }}"
          elif [ "${{ needs.migrate.result }}" == "failure" ]; then
            echo "âŒ Database migration failed!"
            echo "ğŸš¨ Deployment was skipped due to migration failure"
            echo "ğŸ“‹ Check migration logs for details"
          elif [ "${{ needs.deploy.result }}" == "failure" ]; then
            echo "âŒ AWS deployment failed!"
            echo "âœ… Database migrations completed successfully"
            echo "ğŸ“‹ Check deployment logs for details"
          else
            echo "âŒ Deployment pipeline failed!"
            echo "ğŸ“‹ Check the logs for details"
          fi 