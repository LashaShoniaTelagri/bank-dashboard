# TelAgri Monitoring - Advanced Cursor Rules
# Agricultural Finance Management Platform
# Secure Financial Platform Serving Real Farmers' Livelihoods

## üéØ AI ASSISTANT BEHAVIOR & RESPONSE PATTERNS

### Strategic CTO Context
You are working with Lasha Shonia, CTO and co-founder of TelAgri, who values systematic, thorough analysis and strategic decision-making. Always provide:

- **Comprehensive Analysis**: Break down complex problems into structured components
- **Strategic Business Impact**: Connect technical decisions to farmer outcomes, bank partnerships, and platform scalability
- **Security-First Thinking**: Every decision must prioritize banking-grade security and data protection
- **Performance-First Implementation**: Always consider mobile usage in rural areas with limited connectivity
- **Agricultural Domain Expertise**: Understand the seasonal nature of farming and financial cycles
- **Regulatory Compliance**: Consider F-100 reporting requirements and banking regulations
- **Farmer Empathy**: Remember that every feature affects real farmers' access to credit and agricultural success

### Response Quality Standards
- **Structured Responses**: Use tables, sections, and clear hierarchies with banking-themed formatting
- **Actionable Recommendations**: Provide specific next steps and implementation paths for financial platform optimization
- **Context Awareness**: Remember TelAgri's mission to serve farmers and banking partnerships
- **Risk Assessment**: Identify potential security vulnerabilities and compliance issues
- **Performance Metrics**: Include concrete improvements for loading speed, data processing, and user experience
- **Code Examples**: Provide working, production-ready code that maintains banking-grade security
- **Typography Consistency**: NEVER use em dashes (`‚Äî`), always use regular hyphens (`-`) in all text, code, and documentation

### Working Pattern Recognition
When the user asks about:
- **"Analyze"**: Provide comprehensive breakdown with security impact and compliance considerations
- **"Optimize"**: Focus on performance, mobile experience, and database query efficiency
- **"Enhance"**: Offer multiple approaches with security assessment and agricultural domain alignment
- **"Best practices"**: Reference modern fintech standards with specific banking implementation

---

## üèóÔ∏è PROJECT OVERVIEW
You are working on TelAgri Monitoring - a secure financial platform for managing farmer loans, F-100 reports, and bank partnerships in the AgriTech sector. This is a production-grade application handling sensitive financial data affecting farmers' livelihoods.

**Tech Stack:**
- Frontend: React 18 + TypeScript + Vite + shadcn/ui + Tailwind CSS
- Backend: Supabase (PostgreSQL + Auth + Storage + Edge Functions)
- Email: SendGrid integration
- Deployment: AWS (planned)
- Security: 2FA, RLS, JWT tokens, rate limiting

## üéØ CORE PRINCIPLES

### Security First (Banking-Grade)
- ALWAYS implement proper authentication & authorization
- NEVER expose sensitive data in logs or client-side
- ALWAYS use Row Level Security (RLS) for database access
- ALWAYS validate inputs and sanitize outputs
- ALWAYS implement rate limiting for sensitive operations
- ALWAYS use HTTPS and secure headers
- NEVER hardcode credentials or secrets

### Performance & Scalability
- Optimize for mobile-first responsive design
- Implement proper loading states and error boundaries
- Use TanStack Query for efficient data fetching
- Lazy load components and routes where appropriate
- Optimize images and assets for web delivery

### User Experience
- Provide clear feedback for all user actions
- Implement proper error messages with actionable guidance
- Follow accessibility best practices (WCAG 2.1)
- Ensure smooth transitions and animations
- Progressive enhancement approach

## üìÅ PROJECT STRUCTURE & ORGANIZATION STANDARDS

**CRITICAL: Always maintain clean, structured file organization. Follow this structure religiously:**

```
telagri-monitoring/
‚îú‚îÄ‚îÄ src/                          # Frontend source code
‚îÇ   ‚îú‚îÄ‚îÄ components/               # React components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/                   # shadcn/ui base components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ *Modal.tsx            # Feature-specific modals
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ *Table.tsx            # Data tables with filtering
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ *Management.tsx       # CRUD management components
‚îÇ   ‚îú‚îÄ‚îÄ pages/                    # Route-based page components
‚îÇ   ‚îú‚îÄ‚îÄ hooks/                    # Custom React hooks
‚îÇ   ‚îú‚îÄ‚îÄ integrations/             # External service integrations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ supabase/             # Supabase client & types
‚îÇ   ‚îú‚îÄ‚îÄ lib/                      # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ main.tsx                  # Application entry point
‚îú‚îÄ‚îÄ cdk/                          # AWS CDK infrastructure (isolated)
‚îÇ   ‚îú‚îÄ‚îÄ lib/                      # CDK stack definitions
‚îÇ   ‚îú‚îÄ‚îÄ bin/                      # CDK app entry point
‚îÇ   ‚îú‚îÄ‚îÄ package.json              # Infrastructure dependencies
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json             # Infrastructure TypeScript config
‚îÇ   ‚îî‚îÄ‚îÄ README.md                 # Infrastructure documentation
‚îú‚îÄ‚îÄ supabase/                     # Backend infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ migrations/               # Database schema versions
‚îÇ   ‚îú‚îÄ‚îÄ functions/                # Edge Functions for serverless logic
‚îÇ   ‚îî‚îÄ‚îÄ config.toml               # Supabase configuration
‚îú‚îÄ‚îÄ scripts/                      # Automation and utility scripts
‚îÇ   ‚îú‚îÄ‚îÄ setup-*.sh                # Environment setup scripts
‚îÇ   ‚îú‚îÄ‚îÄ *-env-*.sh                # Environment management
‚îÇ   ‚îî‚îÄ‚îÄ validate-*.sh             # Validation and testing scripts
‚îú‚îÄ‚îÄ docs/                         # Organized documentation
‚îÇ   ‚îú‚îÄ‚îÄ README.md                 # Documentation index
‚îÇ   ‚îú‚îÄ‚îÄ QUICK_REFERENCE.md        # Fast access guide
‚îÇ   ‚îú‚îÄ‚îÄ setup/                    # Initial setup and configuration
‚îÇ   ‚îú‚îÄ‚îÄ security/                 # Security guides and best practices
‚îÇ   ‚îú‚îÄ‚îÄ deployment/               # Deployment and infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ development/              # Development guides and templates
‚îÇ   ‚îî‚îÄ‚îÄ api/                      # API documentation
‚îú‚îÄ‚îÄ public/                       # Static public assets
‚îú‚îÄ‚îÄ .cursorrules                  # AI assistant configuration
‚îú‚îÄ‚îÄ .env.template                 # Environment variables template
‚îú‚îÄ‚îÄ package.json                  # Frontend dependencies and scripts
‚îî‚îÄ‚îÄ README.md                     # Project overview
```

**ORGANIZATION PRINCIPLES:**
- **Never create files in project root** unless absolutely necessary (only config files like package.json, .env, etc.)
- **Group related files** in appropriate directories by function and purpose
- **Use descriptive names** that indicate purpose and scope clearly
- **Maintain consistent naming** conventions (kebab-case for files, PascalCase for React components)
- **Document file purposes** in comments, README files, and inline documentation
- **Clean up temporary files** immediately after use - no loose files in root
- **Version control everything** except sensitive data (.env, secrets) and build artifacts (dist/, node_modules/)
- **Separate concerns**: Frontend (src/), Infrastructure (cdk/), Backend (supabase/), Scripts (scripts/), Documentation (docs/)
- **Use proper extensions**: .ts for TypeScript, .tsx for React components, .md for documentation
- **Maintain clean imports**: Use absolute imports with @ alias for src/ directory
- **Follow the established structure religiously** - any deviation must be justified and documented
- **Typography Standards**: NEVER use em dashes (`‚Äî`), always use regular hyphens (`-`) for consistency across all files

## üîß MODERN DEVELOPMENT PATTERNS

### React 18 Banking-Optimized Patterns
```typescript
// Banking-grade component with performance optimization
import { useMemo, useCallback, useRef, useEffect } from 'react';

interface FarmerData {
  id: string;
  name: string;
  bankId: string;
  loanAmount: number;
  status: 'active' | 'pending' | 'defaulted';
  lastPayment: Date;
}

interface BankingTableProps {
  farmers: FarmerData[];
  onStatusChange: (farmerId: string, status: FarmerData['status']) => void;
  isAdmin: boolean;
}

const BankingTable: React.FC<BankingTableProps> = ({ farmers, onStatusChange, isAdmin }) => {
  // Memoize expensive calculations for large datasets
  const sortedFarmers = useMemo(() => 
    farmers.sort((a, b) => b.loanAmount - a.loanAmount), 
    [farmers]
  );

  // Optimized event handlers with security validation
  const handleStatusChange = useCallback((farmerId: string, newStatus: FarmerData['status']) => {
    // Security: Validate admin permissions
    if (!isAdmin && newStatus === 'defaulted') {
      console.warn('üîí Unauthorized status change attempt');
      return;
    }
    
    // Analytics tracking for banking operations
    analytics.track('farmer_status_changed', { 
      farmerId: farmerId.slice(0, 8), // Partial ID for privacy
      newStatus,
      timestamp: new Date().toISOString()
    });
    
    onStatusChange(farmerId, newStatus);
  }, [isAdmin, onStatusChange]);

  return (
    <Table className="banking-table">
      {/* Optimized rendering with React.memo for large datasets */}
    </Table>
  );
};

// Compound component pattern for banking forms
const BankingForm = ({ children, onSubmit }: PropsWithChildren<{ onSubmit: (data: any) => void }>) => {
  const [formData, setFormData] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      // Banking-grade validation and submission
      await onSubmit(formData);
      toast({ title: "Success", description: "Banking operation completed" });
    } catch (error: any) {
      console.error('üè¶ Banking operation failed:', error);
      toast({
        title: "Banking Error",
        description: error.message || "Operation failed. Please contact support.",
        variant: "destructive"
      });
    } finally {
      setIsSubmitting(false);
    }
  }, [formData, onSubmit]);

  return (
    <form onSubmit={handleSubmit} className="banking-form">
      {children}
    </form>
  );
};
```

### TypeScript 5.8+ Banking Domain Patterns
```typescript
// Branded types for banking domain safety
type FarmerId = string & { readonly brand: unique symbol };
type LoanAmount = number & { readonly brand: unique symbol };
type BankId = string & { readonly brand: unique symbol };

// Banking operation types with strict validation
const BANKING_OPERATIONS = {
  LOAN_APPROVAL: 'loan-approval',
  PAYMENT_PROCESSING: 'payment-processing',
  F100_GENERATION: 'f100-generation',
  FARMER_ONBOARDING: 'farmer-onboarding'
} as const satisfies Record<string, string>;

type BankingOperation = typeof BANKING_OPERATIONS[keyof typeof BANKING_OPERATIONS];

// Secure farmer data interface
interface SecureFarmerData {
  id: FarmerId;
  personalInfo: {
    name: string;
    email: string;
    phone?: string;
  };
  bankingInfo: {
    bankId: BankId;
    accountStatus: 'active' | 'suspended' | 'pending';
    creditScore: number;
    loanHistory: LoanRecord[];
  };
  agriculturalInfo: {
    farmSize: number;
    cropTypes: string[];
    seasonalIncome: number;
    lastHarvestDate: Date;
  };
}

// Result pattern for banking operations
type BankingResult<T, E = Error> = 
  | { success: true; data: T; auditLog: AuditEntry }
  | { success: false; error: E; errorCode: string };

// Audit logging for compliance
interface AuditEntry {
  operation: BankingOperation;
  userId: string;
  timestamp: Date;
  ipAddress: string;
  userAgent: string;
  dataAccessed?: string[];
}
```

### Component Architecture
- Use functional components with TypeScript interfaces
- Implement proper prop validation with TypeScript
- Follow compound component pattern for complex UI
- Use React.forwardRef for component library consistency
- Implement proper error boundaries
- **Banking-Grade Security**: Always validate permissions and log sensitive operations
- **Performance Optimization**: Use React.memo, useMemo, and useCallback for large datasets
- **Delete Operations**: ALWAYS require user confirmation for delete actions using AlertDialog component to prevent accidental data loss

### State Management
- Use React hooks for local state
- TanStack Query for server state management
- Context API for global app state (auth, theme)
- useState for simple component state
- useReducer for complex state logic

### Database Patterns
```typescript
// Always use typed Supabase client
const { data, error } = await supabase
  .from('table_name')
  .select('*')
  .eq('user_id', userId);

// Always handle errors gracefully
if (error) {
  console.error('Database error:', error);
  toast({ title: "Error", description: error.message, variant: "destructive" });
  return;
}
```

### Enhanced Error Handling for Banking Operations
```typescript
// Custom error classes for banking operations
class BankingError extends Error {
  constructor(
    message: string,
    public code: string,
    public userFriendlyMessage: string,
    public severity: 'low' | 'medium' | 'high' | 'critical',
    public context?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'BankingError';
  }
}

class ComplianceError extends BankingError {
  constructor(message: string, public regulatoryCode: string) {
    super(
      message, 
      'COMPLIANCE_ERROR', 
      'This operation requires additional verification. Please contact support.',
      'critical',
      { regulatoryCode }
    );
  }
}

class SecurityError extends BankingError {
  constructor(message: string, public securityLevel: 'authentication' | 'authorization' | 'data-breach') {
    super(
      message,
      'SECURITY_ERROR',
      'Access denied. Please verify your credentials.',
      'critical',
      { securityLevel }
    );
  }
}

// Comprehensive error handling for banking operations
async function executeBankingOperation<T>(
  operation: () => Promise<T>,
  operationType: BankingOperation,
  userId: string
): Promise<BankingResult<T>> {
  const auditEntry: AuditEntry = {
    operation: operationType,
    userId,
    timestamp: new Date(),
    ipAddress: getClientIP(),
    userAgent: navigator.userAgent
  };

  try {
    // Pre-operation security validation
    await validateUserPermissions(userId, operationType);
    
    // Execute operation with timeout
    const result = await Promise.race([
      operation(),
      new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error('Operation timeout')), 30000)
      )
    ]);

    // Log successful operation
    await logAuditEntry({ ...auditEntry, status: 'success' });
    
    return { 
      success: true, 
      data: result, 
      auditLog: auditEntry 
    };
  } catch (error) {
    // Enhanced error logging with context
    const bankingError = error instanceof BankingError 
      ? error 
      : new BankingError(
          error.message || 'Unknown banking operation error',
          'UNKNOWN_ERROR',
          'An unexpected error occurred. Please try again or contact support.',
          'medium',
          { originalError: error }
        );

    // Log failed operation with security context
    await logAuditEntry({ 
      ...auditEntry, 
      status: 'failed', 
      error: bankingError.code,
      severity: bankingError.severity 
    });

    // Alert security team for critical errors
    if (bankingError.severity === 'critical') {
      await alertSecurityTeam(bankingError, auditEntry);
    }

    return { 
      success: false, 
      error: bankingError, 
      errorCode: bankingError.code 
    };
  }
}

// Usage in components with proper error boundaries
function FarmerManagement() {
  const handleLoanApproval = async (farmerId: string, loanAmount: number) => {
    const result = await executeBankingOperation(
      () => approveLoan(farmerId, loanAmount),
      BANKING_OPERATIONS.LOAN_APPROVAL,
      currentUser.id
    );

    if (result.success) {
      toast({ 
        title: "Loan Approved", 
        description: `Loan of $${loanAmount} approved for farmer ${farmerId}` 
      });
    } else {
  toast({
        title: "Loan Approval Failed",
        description: result.error.userFriendlyMessage,
    variant: "destructive"
  });
      
      // Additional handling for compliance errors
      if (result.error instanceof ComplianceError) {
        // Redirect to compliance verification flow
        router.push(`/compliance/verify?code=${result.error.regulatoryCode}`);
      }
    }
  };
}
```

## üîê SECURITY REQUIREMENTS

### Authentication & Authorization
- Implement 2FA for all user types (admin, bank viewers)
- Use Supabase Auth with custom claims for role management
- Validate user permissions on both client and server
- Implement session management and automatic logout
- Use secure password requirements and validation

### Data Protection
- Encrypt sensitive data at rest and in transit
- Implement proper CORS policies
- Use environment variables for all secrets
- Sanitize all user inputs
- Implement audit logging for critical operations

### Database Security
```sql
-- Always implement RLS policies
CREATE POLICY "Users can only see their own data" ON table_name
  FOR ALL USING (auth.uid() = user_id);

-- Always validate permissions in Edge Functions
CREATE OR REPLACE FUNCTION check_user_role(required_role text)
RETURNS boolean AS $$
DECLARE
  user_role text;
BEGIN
  SELECT role INTO user_role FROM profiles WHERE id = auth.uid();
  RETURN user_role = required_role OR user_role = 'Administrator';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## üé® UI/UX STANDARDS

### Theme Compliance (CRITICAL REQUIREMENT)
**MANDATORY: All components MUST work perfectly in both light and dark themes**

#### Theme-Aware Color Classes (ALWAYS USE THESE):
```typescript
// ‚úÖ CORRECT - Theme-aware classes
bg-card           // Card backgrounds
bg-background     // Main backgrounds  
bg-muted          // Subtle backgrounds
bg-primary        // Primary actions
text-foreground   // Primary text
text-muted-foreground  // Secondary text
text-heading-primary   // Main headings
text-body-secondary    // Body text
border-border     // All borders
text-destructive  // Error states (instead of text-red-500)

// ‚ùå NEVER USE - Hardcoded colors
bg-white, bg-gray-100, bg-emerald-50
text-gray-900, text-gray-500, text-black
border-gray-300, border-emerald-200
```

#### Dark Mode Patterns:
```typescript
// ‚úÖ CORRECT - Conditional dark mode classes
className="bg-emerald-50 dark:bg-emerald-900/20 text-emerald-800 dark:text-emerald-200"

// ‚úÖ CORRECT - Theme-aware hover states  
className="hover:bg-muted dark:hover:bg-muted/80"

// ‚úÖ CORRECT - Explicit dark mode hover with proper contrast
className="hover:bg-muted dark:hover:bg-muted/80"
// Always specify dark mode hover separately to ensure proper contrast
// Never use hover states that turn black in dark mode

// ‚ùå WRONG - Single theme only
className="bg-white text-gray-900"

// ‚ùå WRONG - Hover that doesn't respect dark mode
className="hover:bg-muted/50"  // Missing dark: variant
```

#### Hover State Requirements (CRITICAL):
- **ALWAYS** specify both light and dark mode hover states explicitly
- **NEVER** use hover states that result in black/dark colors in dark mode without proper contrast
- **ALWAYS** use `dark:hover:bg-muted/80` or similar for ghost/outline buttons in dark mode
- **ALWAYS** test hover states in both themes to ensure visibility and contrast
- **PREFERRED** pattern: `hover:bg-muted dark:hover:bg-muted/80` for consistent theme-aware hover

#### Theme Testing Checklist:
- [ ] Component renders correctly in light theme
- [ ] Component renders correctly in dark theme  
- [ ] All text is readable in both themes
- [ ] All borders are visible in both themes
- [ ] Hover states work in both themes
- [ ] Focus states are visible in both themes

### Component Library (shadcn/ui)
- Always use provided UI components as base
- Extend components with proper className patterns
- Maintain consistent spacing using Tailwind classes
- Follow the established design system
- **CRITICAL**: All custom styling MUST be theme-compliant

### Responsive Design
```typescript
// Mobile-first approach
className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"

// Consistent breakpoints
- sm: 640px (mobile)
- md: 768px (tablet) 
- lg: 1024px (desktop)
- xl: 1280px (large desktop)
```

### Form Patterns
```typescript
// Use React Hook Form + Zod validation
const form = useForm<FormType>({
  resolver: zodResolver(formSchema),
  defaultValues: {...}
});

// Consistent form layout
<Form {...form}>
  <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
    <FormField control={form.control} name="field" render={...} />
    <Button type="submit" disabled={isLoading}>
      {isLoading ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
      Submit
    </Button>
  </form>
</Form>

// REQUIRED: Delete confirmation pattern
const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
const [itemToDelete, setItemToDelete] = useState<string | null>(null);

const handleDeleteClick = (itemId: string) => {
  setItemToDelete(itemId);
  setDeleteConfirmOpen(true);
};

const handleDeleteConfirm = () => {
  if (itemToDelete) {
    deleteMutation.mutate(itemToDelete);
  }
  setDeleteConfirmOpen(false);
  setItemToDelete(null);
};

// Always wrap delete buttons with confirmation
<AlertDialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
  <AlertDialogContent>
    <AlertDialogHeader>
      <AlertDialogTitle>Confirm Deletion</AlertDialogTitle>
      <AlertDialogDescription>
        Are you sure you want to delete this item? This action cannot be undone.
      </AlertDialogDescription>
    </AlertDialogHeader>
    <AlertDialogFooter>
      <AlertDialogCancel>Cancel</AlertDialogCancel>
      <AlertDialogAction onClick={handleDeleteConfirm} className="bg-red-600 hover:bg-red-700">
        Delete
      </AlertDialogAction>
    </AlertDialogFooter>
  </AlertDialogContent>
</AlertDialog>
```

## üìä DATA MANAGEMENT

### Database Schema (Key Tables)
```sql
-- Core entities
profiles          # User profiles with roles
banks            # Bank information and partnerships  
farmers          # Farmer data and loan information
f100             # F-100 financial reports
invitations      # Bank user invitation system
two_factor_codes # 2FA verification codes

-- Always include audit fields
created_at TIMESTAMPTZ DEFAULT NOW()
updated_at TIMESTAMPTZ DEFAULT NOW()
created_by UUID REFERENCES auth.users(id)
```

### API Patterns
```typescript
// Edge Function pattern
export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Always validate request data
const { email, userRole } = await req.json();
if (!email || !userRole) {
  return new Response(JSON.stringify({ error: 'Missing required fields' }), {
    status: 400,
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}
```

## üöÄ DEPLOYMENT (AWS Strategy)

### Infrastructure as Code
- Use AWS CDK or Terraform for infrastructure
- Separate environments: dev, staging, production
- Implement proper CI/CD pipelines with GitHub Actions
- Use AWS CloudFront for static asset delivery

### Service Architecture
```
Frontend (React SPA):
‚îú‚îÄ‚îÄ AWS S3 + CloudFront
‚îú‚îÄ‚îÄ Route 53 for custom domain
‚îî‚îÄ‚îÄ AWS Certificate Manager for SSL

Backend (Supabase):
‚îú‚îÄ‚îÄ Supabase Cloud for database & auth
‚îú‚îÄ‚îÄ AWS Lambda for Edge Functions (if migrating)
‚îú‚îÄ‚îÄ AWS SES/SendGrid for email delivery
‚îî‚îÄ‚îÄ AWS CloudWatch for monitoring

Storage:
‚îú‚îÄ‚îÄ Supabase Storage for F-100 PDFs
‚îî‚îÄ‚îÄ AWS S3 backup for critical data
```

### Environment Configuration & Multi-Environment Support
- **NEVER** hardcode environment-specific values (URLs, project IDs, domains, API endpoints)
- **ALWAYS** use environment detection or configuration for dev/staging/prod environments
- **ALWAYS** use AWS Parameter Store for environment variables
- **NEVER** commit real environment values to repository
- **ALWAYS** separate frontend (VITE_*) and backend variables
- **ALWAYS** use KMS encryption for sensitive parameters
- **ALWAYS** implement environment-aware logic that works across dev/staging/prod

#### Environment Detection Patterns:
```typescript
// ‚úÖ GOOD: Environment-aware URL detection
const getSupabaseUrl = () => {
  if (typeof window !== 'undefined') {
    const origin = window.location.origin;
    if (origin.includes('localhost')) return process.env.VITE_SUPABASE_URL_DEV;
    if (origin.includes('staging')) return process.env.VITE_SUPABASE_URL_STAGING;
    return process.env.VITE_SUPABASE_URL_PROD;
  }
  return process.env.SUPABASE_URL; // Server-side
};

// ‚úÖ GOOD: Edge Function environment detection
const origin = req.headers.get("origin");
const supabaseUrl = origin?.includes("localhost") 
  ? "dev-project-url" 
  : "prod-project-url";

// ‚ùå BAD: Hardcoded values
const supabaseUrl = "https://specific-project.supabase.co";
```

#### Environment Variables Structure:
```bash
# Frontend variables (public, safe in builds)
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key
VITE_APP_URL=https://your-domain.com

# Backend variables (sensitive, server-side only)
SENDGRID_API_KEY=your-sendgrid-key  # NEVER in frontend builds
SUPABASE_DB_PASSWORD=your-password  # NEVER in frontend builds
```

### Infrastructure Management
- **ALWAYS** use AWS CDK for infrastructure as code
- **NEVER** create AWS resources manually in console
- **ALWAYS** version control infrastructure changes
- **ALWAYS** use separate environments (dev, staging, prod)
- **ALWAYS** implement proper IAM least privilege access

## üß™ TESTING STRATEGY

### Testing Pyramid
```typescript
// Unit Tests (Jest + React Testing Library)
test('should render farmer table', () => {
  render(<FarmersTable data={mockData} />);
  expect(screen.getByText('Farmer Name')).toBeInTheDocument();
});

// Integration Tests (Cypress)
cy.get('[data-testid="login-form"]').should('be.visible');
cy.get('input[name="email"]').type('admin@telagri.com');

// E2E Tests (Playwright)
await page.goto('/admin');
await page.click('text=Invite Bank Viewer');
await expect(page.locator('.toast')).toContainText('Invitation sent');
```

### Database Testing
```sql
-- Always test RLS policies
SET ROLE authenticated;
SET request.jwt.claims TO '{"sub": "test-user-id", "role": "authenticated"}';
SELECT * FROM farmers; -- Should only return user's farmers
```

## üîç DEBUGGING & MONITORING

### Logging Patterns
```typescript
// Structured logging
console.log('üîê 2FA verification attempt:', { 
  email: email.replace(/(.{2}).*@/, '$1***@'), // Partially mask email
  timestamp: new Date().toISOString(),
  userAgent: req.headers.get('user-agent')
});

// Error tracking
console.error('‚ùå Database operation failed:', {
  operation: 'insert_farmer',
  error: error.message,
  stack: error.stack
});
```

### Performance Monitoring
- Implement React DevTools Profiler for performance analysis
- Use Supabase Dashboard for database query analysis
- Monitor Edge Function execution times
- Track Core Web Vitals for user experience

## üîÑ MAINTENANCE WORKFLOWS

### Code Quality
```bash
# Pre-commit hooks
npm run lint        # ESLint + Prettier
npm run type-check  # TypeScript validation
npm run test        # Unit test suite
npm run build       # Production build test
```

### Database Maintenance
```sql
-- Regular maintenance tasks
ANALYZE; -- Update table statistics
REINDEX; -- Rebuild indexes if needed
VACUUM; -- Reclaim storage space

-- Monitor slow queries
SELECT query, mean_exec_time, calls 
FROM pg_stat_statements 
ORDER BY mean_exec_time DESC 
LIMIT 10;
```

### Security Audits
- Monthly dependency vulnerability scans
- Quarterly security penetration testing
- Regular review of RLS policies and permissions
- Monitor authentication logs for suspicious activity

## üìö DOCUMENTATION STANDARDS

### Documentation Organization
- **ALWAYS** place documentation in `docs/` folder with proper categorization
- **NEVER** create documentation files in project root (except README.md)
- **ALWAYS** update `docs/README.md` index when adding new documentation
- **ALWAYS** use relative links between documentation files

### Documentation Structure
```
docs/
‚îú‚îÄ‚îÄ README.md                    # Documentation index
‚îú‚îÄ‚îÄ setup/                       # Initial setup and configuration
‚îú‚îÄ‚îÄ security/                    # Security guides and best practices
‚îú‚îÄ‚îÄ deployment/                  # Deployment and infrastructure
‚îú‚îÄ‚îÄ development/                 # Development guides and templates
‚îî‚îÄ‚îÄ api/                        # API documentation
```

### Writing Standards
- Use clear, concise language with step-by-step instructions
- Include code examples with proper syntax highlighting
- Add troubleshooting sections for complex procedures
- Keep security considerations prominent
- Update documentation immediately when making changes
- Test all instructions and code examples before committing

### Documentation Requirements
- **New Features**: Must include documentation in appropriate `docs/` subfolder
- **API Changes**: Must update API documentation
- **Security Changes**: Must update security documentation
- **Deployment Changes**: Must update deployment guides
- **Breaking Changes**: Must update all affected documentation

## üìã COMMON TASKS

### Adding New Features
1. Create feature branch: `feature/description`
2. Update database schema if needed (migration)
3. Implement UI components with TypeScript
4. Add proper error handling and validation
5. Write tests for critical paths
6. **Create/update documentation in `docs/` folder**
7. **Update `docs/README.md` index if needed**
8. Create PR with detailed description

### Bug Fixes
1. Reproduce the issue in development
2. Add debugging logs to understand root cause
3. Write failing test case
4. Implement fix with proper error handling
5. Verify fix doesn't break existing functionality
6. **Update relevant documentation in `docs/` folder**

### Performance Optimization
1. Profile component rendering with React DevTools
2. Analyze database query performance
3. Optimize images and assets
4. Implement code splitting if needed
5. Monitor Core Web Vitals after deployment
6. **Document performance improvements in `docs/development/`**

## ‚ö†Ô∏è CRITICAL CONSIDERATIONS

### Financial Data Handling
- Never log sensitive financial information
- Implement proper data retention policies
- Ensure GDPR compliance for EU farmers
- Regular security audits for PCI compliance consideration

### Agricultural Domain Knowledge
- Understand F-100 report requirements and regulations
- Consider seasonal patterns in farmer loan cycles
- Implement proper validation for agricultural data
- Consider mobile accessibility for field usage

### Scalability Planning
- Design for 10,000+ farmers per bank
- Plan for multiple countries/currencies
- Consider offline functionality for rural areas
- Implement proper caching strategies

---

## üìã AI ASSISTANT TASK PATTERNS FOR TELAGRI

### Banking Platform Optimization Guidelines
When analyzing banking platform opportunities, always check for:
- **Security Compliance**: Are all banking regulations and security standards met?
- **Data Protection**: Is sensitive farmer and banking data properly encrypted and protected?
- **Performance Impact**: Any database queries or operations that could slow down critical banking functions?
- **Mobile Experience**: Touch-friendly interactions for farmers using mobile devices in rural areas?
- **Audit Trail**: All financial operations properly logged for compliance and regulatory requirements?
- **Error Handling**: Graceful handling of banking errors with proper user feedback and security logging?

### Feature Development Framework
When building new features for TelAgri:
1. **Security Impact Assessment**: How does this affect banking-grade security and compliance?
2. **Agricultural Domain Alignment**: Does this serve farmers' real needs and seasonal patterns?
3. **Performance Consideration**: Impact on database performance and mobile user experience?
4. **Regulatory Compliance**: Does this meet F-100 reporting and banking partnership requirements?
5. **Audit Integration**: How will we track and log this feature for compliance?
6. **Farmer Experience**: Does this improve farmers' access to credit and agricultural success?

### Problem-Solving Framework for Banking Platforms
For banking platform optimization challenges:
1. **Security Impact**: Identify which elements affect banking-grade security most
2. **Compliance Analysis**: Map regulatory requirements and audit trail needs
3. **Technical Solutions**: Multiple approaches with security and performance trade-offs
4. **Testing Strategy**: How to validate improvements without compromising security
5. **Implementation Plan**: Specific steps with rollback options and security validation
6. **Success Metrics**: Concrete KPIs for measuring improvement in farmer outcomes

### Quality Gates for Banking Production
Before any deployment to the live banking platform:
- ‚úÖ **Security Validation**: All banking operations properly secured and audited
- ‚úÖ **Performance Testing**: Database queries optimized for large farmer datasets
- ‚úÖ **Compliance Check**: F-100 reporting and regulatory requirements met
- ‚úÖ **Mobile Testing**: Perfect functionality on rural mobile connections
- ‚úÖ **Error Handling**: All banking errors properly caught and logged
- ‚úÖ **Audit Trail**: All financial operations properly tracked for compliance

---

## üöÄ STRATEGIC DEVELOPMENT GOVERNANCE

### Banking-First Decision Framework
For all development decisions:
1. **Security Impact**: How does this affect banking-grade security and data protection?
2. **Farmer Experience**: Does this improve farmers' access to credit and agricultural services?
3. **Performance Implications**: Impact on database performance and mobile user experience?
4. **Regulatory Compliance**: Maintains F-100 reporting and banking partnership standards?
5. **Audit Requirements**: Can we track and log this for compliance and security?
6. **Agricultural Domain**: Serves the seasonal nature of farming and financial cycles?

### Change Management for Banking Operations
1. **Security Assessment**: Clear evaluation of security and compliance impact
2. **Testing Strategy**: Proper validation without compromising live banking operations
3. **Performance Monitoring**: Ensure changes don't hurt database performance or mobile experience
4. **Compliance Validation**: Data-driven verification of regulatory requirement adherence
5. **Implementation Planning**: Gradual rollout with security validation and rollback procedures
6. **Success Measurement**: Concrete metrics improvement in farmer outcomes and banking efficiency

---

**Remember: You are building a financial platform that affects real farmers' livelihoods and access to credit. Every line of code impacts agricultural success and economic opportunity. Code with banking-grade security, regulatory compliance, and deep empathy for the farmers who depend on this platform. This is not just a technical system - it's a bridge between farmers and the financial resources they need to feed communities and build sustainable agricultural businesses.** 